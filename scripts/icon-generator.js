const fs = require("fs");
const path = require("path");

// .env dosyasƒ±nƒ±n doƒüru path'ini belirt
require("dotenv").config({ path: path.join(__dirname, "../.env") });

// AccessoryLibrary'yi import et
const accessoryLibraryData = require("../temp/accessoryLibrary_relevant.json");
const accessoryLibrary = accessoryLibraryData;

// Supabase client'ƒ± import et (optional)
let supabase = null;
try {
  supabase = require("../src/supabaseClient");
  console.log("‚úÖ Supabase baƒülandƒ±");
} catch (error) {
  console.log(
    "‚ö†Ô∏è Supabase baƒülantƒ±sƒ± ba≈üarƒ±sƒ±z, sadece local storage kullanƒ±lacak"
  );
}

const REPLICATE_API_TOKEN = "r8_VOZ18ZqNu1sgLJnZS7Py83sD9HGmYML0uXYyS";
const OUTPUT_DIR = path.join(__dirname, "../generated-icons");
const REFERENCE_IMAGE_PATH = path.join(__dirname, "../example_nano.png");

// Geni≈ületilmi≈ü renk paleti - her icon i√ßin farklƒ± renk garantisi
const COLOR_PALETTE = [
  // Kƒ±rmƒ±zƒ± tonlarƒ±
  "#FF6B6B", // Coral kƒ±rmƒ±zƒ±
  "#E74C3C", // Ate≈ü kƒ±rmƒ±zƒ±sƒ±
  "#C0392B", // Koyu kƒ±rmƒ±zƒ±
  "#FF1744", // Pink kƒ±rmƒ±zƒ±
  "#D32F2F", // Klasik kƒ±rmƒ±zƒ±
  "#B71C1C", // Bordo
  "#FF5722", // Turuncu kƒ±rmƒ±zƒ±

  // Turuncu tonlarƒ±
  "#FF9800", // Turuncu
  "#FF6F00", // Amber turuncu
  "#FF8A65", // A√ßƒ±k turuncu
  "#F57C00", // Koyu turuncu
  "#FF7043", // Deep orange
  "#FFB74D", // Soft turuncu

  // Sarƒ± tonlarƒ±
  "#FFD54F", // Sarƒ±
  "#FFC107", // Amber sarƒ±
  "#FFEB3B", // Parlak sarƒ±
  "#F9A825", // Koyu sarƒ±
  "#FFF176", // A√ßƒ±k sarƒ±
  "#FFD600", // Canary sarƒ±

  // Ye≈üil tonlarƒ±
  "#4CAF50", // Ye≈üil
  "#8BC34A", // A√ßƒ±k ye≈üil
  "#2E7D32", // Koyu ye≈üil
  "#00C853", // Parlak ye≈üil
  "#66BB6A", // Soft ye≈üil
  "#A5D6A7", // Pastel ye≈üil
  "#00BCD4", // Cyan ye≈üil
  "#26A69A", // Teal
  "#009688", // Koyu teal

  // Mavi tonlarƒ±
  "#2196F3", // Mavi
  "#03A9F4", // A√ßƒ±k mavi
  "#0D47A1", // Koyu mavi
  "#1976D2", // Klasik mavi
  "#42A5F5", // Sky mavi
  "#64B5F6", // Soft mavi
  "#81C784", // Ye≈üilimsi mavi

  // Mor tonlarƒ±
  "#9C27B0", // Purple
  "#673AB7", // Deep purple
  "#3F51B5", // Indigo
  "#E91E63", // Pink purple
  "#8E24AA", // Koyu mor
  "#BA68C8", // A√ßƒ±k mor
  "#CE93D8", // Soft mor

  // Ek renkler
  "#607D8B", // Blue grey
  "#795548", // Brown
  "#FF5252", // Red accent
  "#FF4081", // Pink accent
  "#E040FB", // Purple accent
  "#7C4DFF", // Deep purple accent
  "#536DFE", // Indigo accent
  "#40C4FF", // Light blue accent
  "#18FFFF", // Cyan accent
  "#64FFDA", // Teal accent
  "#69F0AE", // Green accent
  "#B2FF59", // Light green accent
  "#EEFF41", // Lime accent
  "#FFFF00", // Yellow accent
  "#FFD740", // Amber accent
  "#FFAB40", // Orange accent
  "#FF6E40", // Deep orange accent

  // Pastel renkler
  "#FFB3BA", // Pastel pembe
  "#FFDFBA", // Pastel turuncu
  "#FFFFBA", // Pastel sarƒ±
  "#BAFFC9", // Pastel ye≈üil
  "#BAE1FF", // Pastel mavi
  "#E6E6FA", // Lavender
  "#FFE4E1", // Misty rose
  "#F0E68C", // Khaki
  "#DDA0DD", // Plum
  "#98FB98", // Pale green
  "#F5DEB3", // Wheat
  "#D3D3D3", // Light grey

  // Vibrant renkler
  "#FF073A", // Neon kƒ±rmƒ±zƒ±
  "#39FF14", // Neon ye≈üil
  "#1B03A3", // Electric blue
  "#FE4164", // Radical red
  "#08E8DE", // Bright turquoise
  "#FBEC5D", // Laser lemon
  "#6A0DAD", // Purple2
  "#FF1493", // Deep pink
  "#00FF7F", // Spring green
  "#DC143C", // Crimson
  "#FF69B4", // Hot pink
  "#32CD32", // Lime green
  "#FF4500", // Orange red
  "#9370DB", // Medium purple
  "#20B2AA", // Light sea green
  "#FF6347", // Tomato
  "#4169E1", // Royal blue
  "#FFD700", // Gold
  "#00CED1", // Dark turquoise
  "#FF8C00", // Dark orange
  "#9ACD32", // Yellow green
];

// √áƒ±ktƒ± klas√∂r√ºn√º olu≈ütur
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Delay fonksiyonu
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// Replicate prediction'ƒ± poll et
async function pollPrediction(predictionId, accessoryName) {
  const MAX_POLL_ATTEMPTS = 60; // 10 dakika (10 saniye x 60)
  let attempt = 0;

  while (attempt < MAX_POLL_ATTEMPTS) {
    try {
      console.log(
        `üîÑ ${accessoryName} polling... (${attempt + 1}/${MAX_POLL_ATTEMPTS})`
      );

      const response = await fetch(
        `https://api.replicate.com/v1/predictions/${predictionId}`,
        {
          headers: {
            Authorization: `Bearer ${REPLICATE_API_TOKEN}`,
            "Content-Type": "application/json",
          },
        }
      );

      if (!response.ok) {
        throw new Error(`Poll API hatasƒ±: ${response.status}`);
      }

      const result = await response.json();

      if (result.status === "succeeded" && result.output) {
        console.log(`‚úÖ ${accessoryName} polling tamamlandƒ±!`);
        // Output direkt string veya array olabilir
        const imageUrl = Array.isArray(result.output)
          ? result.output[0]
          : result.output;
        return { success: true, imageUrl: imageUrl };
      } else if (result.status === "failed") {
        return { success: false, error: result.error || "Prediction failed" };
      } else if (result.status === "canceled") {
        return { success: false, error: "Prediction canceled" };
      }

      // Hala processing durumunda, bekle
      await delay(10000); // 10 saniye bekle
      attempt++;
    } catch (error) {
      console.error(`‚ùå ${accessoryName} polling hatasƒ±:`, error.message);
      await delay(5000); // Hata durumunda 5 saniye bekle
      attempt++;
    }
  }

  return { success: false, error: "Polling timeout - 10 dakika ge√ßti" };
}

// Kullanƒ±lan renkleri takip et
const usedColors = new Set();
let colorCounter = 0; // Basit counter sistemi

// Renk se√ßme fonksiyonu - her accessory i√ßin ger√ßekten farklƒ± renk
function getColorForAccessory(accessoryName, category) {
  // Basit sƒ±ralƒ± renk se√ßimi
  const colorIndex = colorCounter % COLOR_PALETTE.length;
  const selectedColor = COLOR_PALETTE[colorIndex];

  // Counter'ƒ± artƒ±r
  colorCounter++;

  // Rengi kullanƒ±lan renkler listesine ekle
  usedColors.add(selectedColor);

  console.log(
    `üé® ${accessoryName} -> Renk #${colorIndex + 1}: ${selectedColor}`
  );

  return selectedColor;
}

// Renk istatistiklerini g√∂ster
function logColorStats() {
  console.log(`\nüé® RENK ƒ∞STATƒ∞STƒ∞KLERƒ∞:`);
  console.log(`üìä Toplam renk paleti: ${COLOR_PALETTE.length} renk`);
  console.log(`‚úÖ Kullanƒ±lan renkler: ${usedColors.size} renk`);
  console.log(
    `üìà Renk √ße≈üitliliƒüi: ${(
      (usedColors.size / COLOR_PALETTE.length) *
      100
    ).toFixed(1)}%`
  );

  if (usedColors.size === COLOR_PALETTE.length) {
    console.log(`üåà T√ºm renkler kullanƒ±ldƒ±! M√ºkemmel √ße≈üitlilik!`);
  } else if (usedColors.size > COLOR_PALETTE.length * 0.8) {
    console.log(`üéØ Harika renk √ße≈üitliliƒüi!`);
  }
}

// Referans resmi base64'e √ßevir
function getReferenceImageBase64() {
  try {
    if (fs.existsSync(REFERENCE_IMAGE_PATH)) {
      const imageBuffer = fs.readFileSync(REFERENCE_IMAGE_PATH);
      const base64 = imageBuffer.toString("base64");
      return `data:image/png;base64,${base64}`;
    } else {
      console.warn("‚ö†Ô∏è Referans resim bulunamadƒ±:", REFERENCE_IMAGE_PATH);
      return null;
    }
  } catch (error) {
    console.error("‚ùå Referans resim okunamadƒ±:", error.message);
    return null;
  }
}

// Icon olu≈üturma fonksiyonu
async function generateIcon(accessoryName, category, retryCount = 0) {
  const MAX_RETRIES = 3;

  // 3D isometric stil kullandƒ±ƒüƒ±mƒ±z i√ßin renk belirtmiyoruz

  console.log(
    `üé® ${accessoryName} iconunu olu≈üturuyor... (Kategori: ${category})`
  );

  const prompt = `Create a 3D isometric icon of a ${accessoryName}:
- centered in the frame
- simple clay-like rendering style
- soft pastel colors with smooth gradients
- subtle shadows and highlights
- white background
- consistent proportions, medium size
- playful, modern, app-icon style`;

  const requestBody = {
    input: {
      prompt: prompt,
      output_format: "png",
    },
  };

  // Referans resim base64 formatƒ±nda ekle
  const referenceImage = getReferenceImageBase64();
  if (referenceImage) {
    requestBody.input.image_input = [referenceImage];
    console.log(`üì∑ Referans resim eklendi (base64)`);
  } else {
    console.log(`‚ö†Ô∏è Referans resim eklenemedi`);
  }

  try {
    const response = await fetch(
      "https://api.replicate.com/v1/models/google/nano-banana/predictions",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${REPLICATE_API_TOKEN}`,
          "Content-Type": "application/json",
          Prefer: "wait",
        },
        body: JSON.stringify(requestBody),
      }
    );

    if (!response.ok) {
      throw new Error(
        `API hatasƒ±: ${response.status} - ${response.statusText}`
      );
    }

    const result = await response.json();

    if (result.status === "succeeded" && result.output) {
      // Output direkt string veya array olabilir
      const imageUrl = Array.isArray(result.output)
        ? result.output[0]
        : result.output;
      console.log(`üîó Image URL: ${imageUrl}`);
      await downloadImage(imageUrl, accessoryName, category);
      console.log(`‚úÖ ${accessoryName} ba≈üarƒ±yla olu≈üturuldu!`);
      return { success: true, accessoryName, category };
    } else if (result.status === "processing") {
      // Prediction i≈üleniyor, poll et
      console.log(
        `‚è≥ ${accessoryName} i≈üleniyor... Prediction ID: ${result.id}`
      );
      const finalResult = await pollPrediction(result.id, accessoryName);

      if (finalResult.success) {
        await downloadImage(finalResult.imageUrl, accessoryName, category);
        console.log(`‚úÖ ${accessoryName} ba≈üarƒ±yla olu≈üturuldu!`);
        return { success: true, accessoryName, category };
      } else {
        throw new Error(finalResult.error);
      }
    } else {
      throw new Error(
        `G√∂r√ºnt√º olu≈üturulamadƒ±: ${
          result.error || result.detail || "Bilinmeyen hata"
        }`
      );
    }
  } catch (error) {
    console.error(`‚ùå ${accessoryName} olu≈üturulurken hata:`, error.message);

    if (retryCount < MAX_RETRIES) {
      console.log(
        `üîÑ ${accessoryName} i√ßin yeniden deneniyor... (${
          retryCount + 1
        }/${MAX_RETRIES})`
      );
      await delay(2000); // 2 saniye bekle
      return generateIcon(accessoryName, category, retryCount + 1);
    } else {
      console.error(
        `üíÄ ${accessoryName} i√ßin maksimum deneme sayƒ±sƒ±na ula≈üƒ±ldƒ±`
      );
      return { success: false, accessoryName, category, error: error.message };
    }
  }
}

// Supabase'e upload fonksiyonu (optional)
async function uploadToSupabase(buffer, fileName, accessoryName, category) {
  if (!supabase) {
    console.log(
      `‚è≠Ô∏è Supabase baƒülantƒ±sƒ± yok, ${fileName} sadece local'e kaydedildi`
    );
    return null;
  }

  try {
    const supabasePath = `generated-icons/${fileName}`;

    const { data, error } = await supabase.storage
      .from("icons")
      .upload(supabasePath, buffer, {
        contentType: "image/jpeg",
        upsert: true,
      });

    if (error) {
      throw error;
    }

    console.log(`‚òÅÔ∏è ${fileName} Supabase'e y√ºklendi`);

    // Public URL al
    const { data: publicData } = supabase.storage
      .from("icons")
      .getPublicUrl(supabasePath);

    return {
      path: supabasePath,
      publicUrl: publicData.publicUrl,
      bucket: "icons",
    };
  } catch (error) {
    console.error(`Supabase upload hatasƒ±:`, error.message);
    return null; // Hata durumunda null d√∂n, i≈ülemi durdurma
  }
}

// G√∂r√ºnt√ºy√º indirme ve kaydetme fonksiyonu
async function downloadImage(imageUrl, accessoryName, category) {
  try {
    console.log(`üì• ƒ∞ndiriliyor: ${imageUrl}`);
    const response = await fetch(imageUrl);
    const buffer = await response.arrayBuffer();

    // Dosya adƒ±nƒ± g√ºvenli hale getir
    const safeFileName = accessoryName
      .replace(/[^a-zA-Z0-9]/g, "_")
      .toLowerCase();
    const fileName = `${category}_${safeFileName}.png`;
    const filePath = path.join(OUTPUT_DIR, fileName);

    // Buffer'ƒ± Node.js Buffer'ƒ±na √ßevir
    const nodeBuffer = Buffer.from(buffer);

    // Local'e kaydet
    fs.writeFileSync(filePath, nodeBuffer);
    console.log(`üíæ ${fileName} local'e kaydedildi`);

    // Supabase'e y√ºkle
    const supabaseResult = await uploadToSupabase(
      nodeBuffer,
      fileName,
      accessoryName,
      category
    );
    console.log(`üåê Public URL: ${supabaseResult.publicUrl}`);

    return {
      localPath: filePath,
      fileName: fileName,
      supabase: supabaseResult,
    };
  } catch (error) {
    console.error(`G√∂r√ºnt√º indirilemedi:`, error.message);
    throw error;
  }
}

// T√ºm iconlarƒ± olu≈ütur
async function generateAllIcons() {
  console.log("üöÄ Icon Generator ba≈ülatƒ±lƒ±yor...");
  console.log(`üìÅ √áƒ±ktƒ± klas√∂r√º: ${OUTPUT_DIR}`);

  const results = {
    successful: [],
    failed: [],
  };

  let totalCount = 0;
  let processedCount = 0;

  // Toplam item sayƒ±sƒ±nƒ± hesapla
  Object.keys(accessoryLibrary).forEach((category) => {
    totalCount += accessoryLibrary[category].length;
  });

  console.log(`üìä Toplam ${totalCount} icon olu≈üturulacak`);

  // Her kategori i√ßin iconlarƒ± olu≈ütur
  for (const [category, accessories] of Object.entries(accessoryLibrary)) {
    console.log(
      `\nüìÇ ${category} kategorisi i≈üleniyor... (${accessories.length} item)`
    );

    for (const accessory of accessories) {
      processedCount++;
      console.log(`\n[${processedCount}/${totalCount}] ƒ∞≈üleniyor...`);

      const result = await generateIcon(accessory.name, category);

      if (result.success) {
        results.successful.push(result);
      } else {
        results.failed.push(result);
      }

      // API rate limit i√ßin kƒ±sa bir bekleme
      await delay(1000);
    }
  }

  // Sonu√ßlarƒ± g√∂ster
  console.log("\n" + "=".repeat(50));
  console.log("üìä SONU√áLAR:");
  console.log(`‚úÖ Ba≈üarƒ±lƒ±: ${results.successful.length}`);
  console.log(`‚ùå Ba≈üarƒ±sƒ±z: ${results.failed.length}`);
  console.log(`üìà Toplam: ${totalCount}`);

  if (results.failed.length > 0) {
    console.log("\n‚ùå Ba≈üarƒ±sƒ±z olanlar:");
    results.failed.forEach((item) => {
      console.log(`  - ${item.category}/${item.accessoryName}: ${item.error}`);
    });
  }

  // Sonu√ßlarƒ± JSON olarak kaydet
  const reportPath = path.join(OUTPUT_DIR, "generation-report.json");
  fs.writeFileSync(
    reportPath,
    JSON.stringify(
      {
        timestamp: new Date().toISOString(),
        totalCount,
        successful: results.successful.length,
        failed: results.failed.length,
        details: results,
      },
      null,
      2
    )
  );

  console.log(`\nüìÑ Rapor kaydedildi: ${reportPath}`);
  console.log("üéâ Icon generation tamamlandƒ±!");
}

// Belirli bir kategori i√ßin iconlarƒ± olu≈ütur
async function generateCategoryIcons(categoryName) {
  if (!accessoryLibrary[categoryName]) {
    console.error(`‚ùå Kategori bulunamadƒ±: ${categoryName}`);
    console.log(
      "Mevcut kategoriler:",
      Object.keys(accessoryLibrary).join(", ")
    );
    return;
  }

  console.log(
    `üöÄ ${categoryName} kategorisi i√ßin icon generation ba≈ülatƒ±lƒ±yor...`
  );

  const accessories = accessoryLibrary[categoryName];
  const results = { successful: [], failed: [] };

  for (let i = 0; i < accessories.length; i++) {
    const accessory = accessories[i];
    console.log(
      `\n[${i + 1}/${accessories.length}] ${accessory.name} i≈üleniyor...`
    );

    const result = await generateIcon(accessory.name, categoryName);

    if (result.success) {
      results.successful.push(result);
      console.log(
        `‚úÖ Ba≈üarƒ±lƒ±: ${results.successful.length} / ƒ∞≈ülenen: ${i + 1}`
      );
    } else {
      results.failed.push(result);
      console.log(`‚ùå Ba≈üarƒ±sƒ±z: ${results.failed.length} / ƒ∞≈ülenen: ${i + 1}`);
    }

    await delay(1000);
  }

  console.log("\n" + "=".repeat(30));
  console.log(`üìä ${categoryName} SONU√áLARI:`);
  console.log(`‚úÖ Ba≈üarƒ±lƒ±: ${results.successful.length}`);
  console.log(`‚ùå Ba≈üarƒ±sƒ±z: ${results.failed.length}`);
}

// CLI arg√ºmanlarƒ±nƒ± kontrol et
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    generateAllIcons().catch(console.error);
  } else if (args[0] === "--category" && args[1]) {
    generateCategoryIcons(args[1]).catch(console.error);
  } else if (args[0] === "--list-categories") {
    console.log("Mevcut kategoriler:");
    Object.keys(accessoryLibrary).forEach((category) => {
      console.log(`- ${category} (${accessoryLibrary[category].length} item)`);
    });
  } else {
    console.log("Kullanƒ±m:");
    console.log(
      "  node icon-generator.js                    # T√ºm iconlarƒ± olu≈ütur"
    );
    console.log(
      "  node icon-generator.js --category Casual  # Sadece belirli kategori"
    );
    console.log(
      "  node icon-generator.js --list-categories  # Kategorileri listele"
    );
  }
}

module.exports = {
  generateIcon,
  generateAllIcons,
  generateCategoryIcons,
};
